# 解析器
每一个写过代码的人都听说过解析器，其中大部分都是`parser error`，或许也听说的比如这样“我们需要解析它”，“在它解析后“，”这个解析器搞砸了输入“。”解析器“这个词和”编译器“，
"解释器”和“编程语言”一样普通。每个人都知道解析器存在，但是它们理解是正确的吗？原因是还有谁应该对`parser error`负责。

但是什么才是真正的解析器？它的作用是什么，它应该要做些什么？下面是维基百科的[定义](https://en.wikipedia.org/wiki/Parsing#Parser):
> 解析器是软件的组成部分，它输入数据（通常为文本）并且构建数据结构，往往是一种解析树，抽象语法树或者其他继承体系结构。它们给出了输入的结构，在过程中也检查的其中语法错误。解析器的的先前步骤通常是词法分析器，它从输如的字符串序列生成token。

从维基百科中计算机科学主题的摘录的文章非常容易理解，我们甚至认出了我们词法解析器。

一个解析器将一个输入转变为一个数据结构，它代表了输入。它听上去相当抽象，所以让我用几个例子来举例说明，下面一个`JavaScript`代码：
```js
> var input = '{"name": "Thorsten", "age":28}'
> var output = JSON.parse(input)
> output
{name: 'Thorsen', age: 28}
> output.name
'Thorsen'
> output.age
28
```
我们的输入时一些文本、字符串。我们将他们传递给隐藏在`JSON.parse`函数中的解析器然后得到输出值，输出内容代表了输入：一个JavaScript对象，包含了两个字段`name`和`age`,他们的值对应着输入。现在我们可以很轻松的使用这个数据结构访问`name`和`age`字段。

但是你可能会说：”一个JSON解析器和一个编程语言的解析器是不一样的”。我想会说的是，他们是不相同的，至少不同的概念层面上的。一个JSON解析器输入文本然后构建一个数据结构来表示输入，这也是编程语言的解析器的所做的工作。不同点在于JSON解析器你可以根据输入看到数据结构，然后当你看看在这个
```js
if ((5+2*3)==91) { return computerStuff(input1, input2); }
```
这个数据结构当然不能一下子看出来，这也是为什么，至少对于我来讲，它的不同点在于概念层面上更深。我猜测这概念层面上的不同主要在于缺乏对于编程语言解析器的熟悉程度和它生成的数据结构。相对于编写编程语言，我有更多的很多写JSON的经验，通过解析器解析它，查看它的输出和结构。作为编程语言的使用者，我们很少看到和接触过解析后的源代码，以及中间的表示形式。Lisp程序员是这个规则的例外，在Lisp代码中，表示源码的数据结构和Lisp用户是同样的。解析后的源代码和和程序的数据是一样的。"代码就是数据，数据就是代码”这句话你有时会从Lisp程序员嘴中说出。

所以为了让我们对编程语言解析器的概念层面的理解提升到我们对一些序列化语言（比如JSON，YAML, TOML, INI等等），我们需要理解他们生成的数据结构。

在大多数解析器和编译器中，源代码中的中间表示形式的数据结构叫做语法树或者抽象语法树。“抽象”的概念基于这样一个事实，在抽象语法树中代码的详细细节我们忽略掉了。分号、换行、空白、注释、花括号、中括号和括号这些都是依赖于语言，解析器并不会在抽象语法树中表示它们，它们仅仅指导如何去构建这颗树。

一个事实需要主要的是，没有一个唯一正确的、通用的抽象语法树适用于每一个解析器。它们实现都是比较类似、概念上是一样的，但是细节上有所不同。具体的实现取决于它要解析的编程语言。

一个小例子可以说清楚，加入说我们有如下的源代码：
```js
if ( 3 * 5 > 10) {
    return "hello";
}else{
    return "goodbye";
}
```
假设我们使用`JavaScript`，拥有一个`MagicLexer`解析器，它能构建出一个用JavaSrcipt对象构成的抽象语法树，那么解析过程中将会生成如下的内容:
```js
> var input = `if (3 * 5 > 10) { return "hello";} else { reutrn "goodby" ;}`
> var tokens = MagicLexer.parse(input)
> MagicLexer.parser(tokens);
{
    type: "if-statement",
    condition :{
        type: "operator-expression",
        operator : ">",
        left: {
            type: "operator-exression",
            operator: "*",
            left: {
                type: "integer-literal", value : 3
            },
            right :{
                type: "integer-literal", value: 5
            }
        },
        right:{
            type:"integer-literal", value: 10
        }
    },
    consequence: {
        type: "return-statement",
        returnValue: {type: "string-literal", value: "hello"}
    },
    alternative:{
        type: "return-statement",
        returnValue: {type: "string-literal", value: "goodbye"}
    }
}
```
正如你看到的，解析器输出的抽象语法树，相当抽象。在这里没有括号，没有冒号和花括号。但是它很精确的表示出了源代码，你认为呢？我打赌你当你看源代码的时候就能看到抽象语法树了。

所以这就是解析器所做的工作。它将源代码作为输入（文本和token都可以）然后输出数据结构，它代表了源代码。当构建数据结构的时候，它们不可避免地分析了输入，检查它们是否满足期待数据结构，因此解析的过程也被称为语法分析。

在本章中，我们将为我们的Monkey编程语言编写解析器。它的输入将会我们前面章节定义好的`token`,它们是有词法分析器完成，我们将会定义我们自己的抽象语法树，它将适应我们的解析器，然后构建一个抽象语法树的实例通过递归解析`token`。