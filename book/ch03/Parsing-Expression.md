**解析表达式**

主管的来讲，解析表达式是编写解析器中最有趣的部分。正如我们刚刚看到的，解析语句相对比较直接。我们从左到右处理每个`token`，期待或者拒绝下一个token直到我们返回抽象语法树的节点。

从另一方面来讲，解析表表达式有更多的挑战。操作符优先级是第一个需要考虑的，家接下来就是一个例子，我们说我们想要解析如下的算术表达式：
```
5 * 5 + 10
```
我们想要让我们的抽象语法树用以下的的形式来表达：
```
((5 * 5) + 10)
```
也就是说`5*5`在抽象语法树中要更低一些，比加法更早地执行。为了生成这样的抽象语法树，解析器需要知道操作符的优先级，也就是`*`的优先级比`+`要高，这也是常见的操作符优先级例子，但是在某些情况下，这个就非常重要了。考虑到如下形式：
```
5 * (5 + 10)
```
在这里，括号将`5+10`表达式组在一起，使它们的优先级得到提升。现在加法在乘法之前执行。因为括号比`*`有更高的优先级。接下来我们会看到更多的例子，优先级扮演着重要的角色。

另外一个挑战是在表达式中，同样的`token`可以出现在不同的位置。与之相反的是，`let`只能出现在`let`语句的开始的地方，这样很容易帮我们决定剩下的语句应该是什么。比如看下面的表达式：
```
-5-10
```
在这里`-`操作符出现在表达式开始的地方，作为前缀操作符。然后组委中缀操作符出现在中间。同样的挑战如下：
```
5 * (add(2, 3) + 10)
```
尽管你可能不会认为括号也作为操作符，但是它同样出现了刚刚`-`中的问题。最外面的括号表示组合表达式，里面的括号表示了调用表达式。`token`位置是否有效取决于上下文，来确定它们之间的优先级。

**Monkey中的表达式**

在Monkey编程语言中，除了`let`和`return`语句外，其余的都是表达式，这些表达式有不同的形式。

Monkey语言中的前缀表达式
```
-5
!true
!false
```
当然也有中缀表达式
```
5 + 5
5 - 5
5 / 5
5 * 5
```
除了基础的算术操作符，也有一些比较操作符：
```
foo == bar
foo != bar
foo < bar
foo > bar
```
当然正如我们先前看到的，我们可以使用括号将表达式组合起来影响执行的顺序：
```
5 * (5 + 5)
(( 5 + 5 ) * 5) * 5
```
还有调用表达式
```
add(2, 3)
add(add(2, 3), add(5, 10)) max(5, add(5, (5 * 5)))
```
标识符同样也是表达式
```
foo * bar / foobar
add(foo, bar)
```
函数在Monkey中也是一等公民，字面函数也是表达式。我们可以使用`let`语句讲一个函数绑定到一个名字上。字面函数就是语句形式的表达式。
```
let add = fn(x, y) { return x+y };
```
我们也可以用字面函数代替标识符
```
fn(x, y) { return x + y }(5, 5) 
(fn(x) { return x }(5) + 10 ) * 10
```
和其他语言一样，我们也有`if`表达式
```
let result = if (10 > 5) {true} else {false};
result // => true
```
看到上述所有的不同形式的表达式，我们非常清楚需要一个很好的方法来正确的解析它们。我们老的方法是基于当前的Token来决定接下来要做什么并不能再次帮助我们，现在就是`Vaughan Patt`方法大显神威的时候。

**指定向下操作符优先级**
Vaughan Patt在他的`指顶向下操作符优先级`论文中提出了新的方法来解析它们，他的原文是这样的：
> ……这非常容易理解、实现和使用，在实际使用中非常高效，而且满足大多部分用户来的需要。

这篇论文在1973发表，但是在Pratt提出这个想法后很多年都没有支持者。知道最近几年，其他开发人员发现了Pratt的论文，编写实现他们导致`Pratt`的方法变得流行起来。Douglas Crockford的`JavaSrcipt: The Good Part`文章中，显示了如何将`Pratt`的想法用JavaScript实现。同样也有一片特别推荐的文章，是由Bob Nystrom写的，他是著名的`Game Programming Patterns`书的作者。它认为Pratt的方法非常容易理解和实现，并且简单的用Java实现了几个例子。

这个解析方法由三种描述，被发明出来作为基于上下文无关文法和BNF的解析器的替代方案。

同样也有主要的不同点：不同于由解析函数（在parseLetStatement中）由语法规则（在BNF或者EBNF中定义）定的，Pratt方法通过将单个`token`类型和函数联系起来。该想法中最重要的部分是每个`token`类型有两个解析函数，取决于该`token`的位置：中缀或者前缀。

我猜现在还没有更大的意义，我们还没有看到如何将一个解析函数和语法结合起来，所以将`token`类型而不是语法规则并没有产生很大的作用，老实地说，我在写这小节的时候，我面临则“鸡生蛋和蛋生鸡”的问题。有没有更好的方法用抽象的术语来解释这个算法和展示实现过程？会不会导致你不停地翻页？或者可能导致你跳过实现的部分？

答案是我决定不采用这两种方式。我们接下来要做的不是实现解析表达式而是近距离地看这个算法。最后我们将会拓展和完成该算法使之能够解析Monkey中的所有的表达式。

在开始编写代码之前，我们先厘清一些概念。