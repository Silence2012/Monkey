**词法解析**
为了让我们的源码工作，我们需要转变一种更加容易访问的形式。就跟我们纯文本工作一样简单。它会变得更加沉重但是更快的，如果我们想要将一种编程语言转换为另外一种编程语言。

所以我们所需要做的工作就是将源代码用另外一种新式表达出来，以便更加容易工作。在执行之前，我们将会源代码的形式转变为两次。
![](../figures/transform.png)
首先要做的转换为将源代码转换为token，这个过程叫做词法分析，它是由词法分析器完成的。

token本身是非常小，分门别类的的数据结构，它们将会被送到解析器中，这将是第二步的转换，将token转换为抽象语法树。

下面是简单的例子，它是词法解析器的一个输入：
```
"let x = 5 + 5;"
```
那么从词法解析器中的输出将会是
```
[
    LET,
    IDENTIIER("x"),
    EQUAL_SIGN,
    INTEGER(5),
    PLUS_SIGN,
    INTEGER(5),
    SEMICOLON
]
```
这里每一个token都对应于源码中的一部分。 `"let"`对应着`LET`, `"+"`对应着`PLUS_SIGN`，等等如此。其余像`IDENTIFIER`和`INTEGER`对应着具体的值`5`而不是`"5"`，在`INTEGER`和`"x"`对应`INDENTIFIER`。但是具体的token构成有着不同的实现。比如，一些词法解析器将`"5"`转换为一个整型，但是其他的解析并不这样做。

还有一点值得注意的是，空白符将会被忽略。在我们的例子中是可以的，因为空白符在Monkey语言中没有意义的。比如如果我们输入如下是没有问题的:
```
let x = 5;
```
或者这么输入:
```
let x  =  5;
```
像其他语言，比如Python，空白符是有意义的，这也就意味着词法解析器不能讲它们"吃掉"，也包括换行符。词法解析器也将它们作为token输出。

一个好的的词法解析器的每个token也可能包含的行号，列号以及文件名。为什么要这么做呢？举个例子来讲，在后面的过程中如果我们解析的过程中，如果出现错误，可以输出相应的信息，而不是仅仅的输出`"error: expected semicolon token"`，可以输出：
```
"error: expected semicolon token. line 42, coloumn 23, program.monkey"
```
但是我们并不打算这么做，并不是因为这个太复杂，而是它会将我们的token和词法解析器变得复杂起来，变得更加难以理解。